<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-开发准备（二）]]></title>
    <url>%2F2018%2F09%2F19%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[技术栈 平台： Node.js（v8.9.3） 框架：Express（v4.16.0） 数据库：MongoDB（v3.4.14） 开发环境 Node相关：下载链接 MongoDB相关：下载链接 Node与MongoDB的下载与安装，请自行百度或谷歌，遍地都是，不再赘述。 相关规范相关规范主要包括代码规范、Git commit规范和API接口文档规范。 代码规范代码规范采用JavaScript Standard Style,以下简称standard规范。至于为什么使用这个代码规范，没有什么特殊原因，这是我使用过的第一个代码规范，是我规范自己代码的开始，习惯而已，并且github上的start数也不算少。standard规范相比较ESLint而言，最舒服的一点就是不用配置，对我影响最大的一点是代码中再也没有出现分号，并且强迫症再也受不了代码中有分号【捂脸】，以至于后来使用ESLint时，也要配置为可以不写分号【再次捂脸】。 通过代码规范，可以在编程过程中避免一些低级错误，比如使用未定义的变量等，同时可以规范自己的代码书写风格，有了规范代码的习惯，写出来的代码赏心悦目，看着也舒服很多，一定程度上增加了代码的可读性，工作效率的提升也是必然的事情。 我听说过，有的团队的代码规范及其严格，比如一行代码最大字符长度不能超过120甚至80，每个函数的代码行数不能超过50行等，存在必有意义吧，起初没必要对自己这么严格，但是代码规范还是要重视起来的。 工具配合我使用的编辑器是VS Code,可以安装StandardJS插件，非常方便。 同时可以配合一个npm的库包pre-commit进行代码规范，因为不规范的代码是不会影响程序的正常运行的，但我们使用代码规范的目的就是希望提交到代码仓库的代码都是规范的，pre-commit的作用就是在进行commit操作时检测所有代码是否符合standard规范，如果不符合则不允许提交代码。 相关参考在standard规范的文档中，有关于规范的细则和使用过程中可能出现的问题。 standard规范的中文文档 standard规范的github链接 pre-commit链接 Git commit规范我们进行commit操作时，填写的相关说明一定是要有意义的，我记得在学习编程的最开始，我们的对git的命令以及操作规范不清楚，所以commit的信息乱七八糟，经常是“解决冲突”、“修改bug”这样的说明，在被批评之后，也仅仅是commit信息不再胡写。 项目的commit message规范使用的是主流的Angular规范，在实际的团队开发中，通过对commit日志的规范，有助于代码的review、日志的自动化生成以及项目发版，同时能够很好地熟悉git工作流。在该项目中不涉及发版，只是简单的开发，所以只是遵循了部分规范，在实际工作中，如果团队刚好涉及到git工作流的规范，那肯定是要遵循的。 Git commit日志基本规范基础语法模板&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 规范的基本说明：type代表本次提交的类型，是新增feature还是修复bug或是修改文档等，主要类型及其说明如下： feat：新增feature fix: 修复bug docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 优化相关，比如提升性能、体验 test: 测试用例，包括单元测试、集成测试等 chore: 改变构建流程、或者增加依赖库、工具等 revert: 回滚到上一个版本 scope表明本次修改的范围或者模块，例如users。 subject是对变更内容的简要描述。 BLANK LINE不用说，就是字面意思的空白行。 body是对本次变更更加详细的说明，可以是发起本次变更的原因以及本次变更的解决思路和方法等。 footer处填写相关连接。 格式要求：# 标题行：50个字符以内，描述主要变更内容# （我是空行）# 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:# （我是空行）# * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险? ## 尾部：如果需要的话可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。 相关参考Git commit message和工作流规范 API接口文档规范我写过的第一个接口文档，是word形式的，写了大概三个接口就受不了了，word写接口，太不舒服了，后来用showdoc工具写接口文档，好用了很多，但是没有很好地体现文档的维护记录，再后来，参加工作之后接触了解了apidoc，相对而言，它也算主流之一，使用简单并且支持多语言，所以就开始使用apidoc作为生成接口文档的工具，接口文档在代码中以注解的形式书写，然后通过apidoc的相关命令生成接口文档，配合git刚好可以很好地体现接口文档的维护记录。当然，还有其他选择，个人喜好而已。 apidoc编写接口示例代码实例：/** * @api &#123;POST&#125; /user create a user * @apiDescription 用户新增的接口 * @apiName 用户注册 * @apiGroup User * @apiUse userParams * @apiSuccessExample Success-Response: * &#123; * errorCode: 0, * status: 200, * data: &#123; * _id: '123', * name: 'morehao', * createdAt: '20180913', * updatedAt: '20180913', * lastLogin: '暂未登录' * &#125; * &#125; * @apiErrorExample &#123;json&#125; Error-Response: * &#123; * status: 200, * errorCode: 20100, * errorMsg: '该用户已经存在' * &#125;*/ 截图实例： 相关参考这里只确定API接口文档的生成方式，详细的使用后面也不会过多涉及，下面附上相关链接。 apidoc官方网站 apidoc文档的官方示例 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-前言（一）]]></title>
    <url>%2F2018%2F09%2F18%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E5%89%8D%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目的目的是什么首先说明，项目的目的并不是写教程，我目前的水平还处于菜鸟级别，若有指正，菜鸟必改之。 我刚刚开始学习编程的时候，我的老师告诉我先做一个个人博客来练手，当时没怎么听，也只是走了个过场，刚好可以完成下当年没有做的博客。同时，通过完成个人博客项目，我想要把之前学习到的、接触到的和工作中使用到的经验，比如搭建基础的项目框架，比如代码规范和Git commit规范，比如路由分离，比如错误处理等等，尽可能地体现在这个功能简单的个人博客中。 总之，本项目的目的并不是要做多么酷炫的功能，也不是想要做什么教程，仅仅是个人经验的总结，希望即使是一个个人博客系统也可以像一个工程。当然，如果能够帮助到一些人，那也是极好的【手动捂脸】。 项目的预期我是一个【纯粹】的Node后端开发，说是纯粹，其实是菜，前端的东西，我看到就头大，目前也不太想花费精力去学习前端的东西，所以本项目完成之后，有的只是一个个人博客所拥有的基础功能的——一堆接口【手动捂脸】，我也尝试着使用iview提供的一套后台管理系统进行改写，写了几天之后，发现意义不大，我的想法并不是做一个完善的包含前后端的个人博客，所以也就放弃了。 所以，综上，你不会看到酷炫的功能，更看不到酷炫的页面，这里只会有一堆接口，当然，我会提供较为完善的接口文档，毕竟，接口文档也是项目开发过程中极为重要的一部分。 项目的结果虽然只是一个简单的纯后端的个人博客，但是在完成这个项目的过程中还是学习到不少的知识，也对有些曾经不太熟悉的东西有了新的认识，并且项目已经完成，可能还有一些地方需要完善，比如接口文档知识写了示例，比如测试代码也只是写了一个接口，这些不完善的地方，我应该还是会去完善的，不过，我是不定期完善【手动捂脸】。 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node回调函数改写]]></title>
    <url>%2F2018%2F06%2F26%2FNode%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%94%B9%E5%86%99%2F</url>
    <content type="text"><![CDATA[以读取文件为例，首先，创建文件a.txt，文件内写入内容Hello world!。 回调函数写法const fs = require('fs')fs.readFile('./a.txt', 'utf-8', (err, data) =&gt; &#123; if (err) throw err console.log(data)&#125;) Promise写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;getTxt('./a.txt') .then(rst =&gt; console.log(rst)) bluebird写法const Promise = require('bluebird')const fs = Promise.promisifyAll(require('fs'))fs.readFileAsync('./a.txt', 'utf-8') .then(data =&gt; console.log(data)) Generator写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;function * fun () &#123; yield getTxt('./a.txt')&#125;const run = fun()run.next().value.then(data =&gt; console.log(data)) async/await写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;async function run (params) &#123; const file = await getTxt(params) console.log(file) return file&#125;run('./a.txt')]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用VScode断点调试Node.js]]></title>
    <url>%2F2018%2F05%2F09%2F%E4%BD%BF%E7%94%A8VScode%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Node-js%2F</url>
    <content type="text"><![CDATA[这是个告别console的开始【手动捂脸】。 首先，打开虫子，进入调试页面。 点击绿色的按钮，开始调试。 选择环境Node.js。 选择完成之后，生成一个.vscode文件夹，文件夹下有个launch.json文件。 将【program】字段的值修改为自己程序的入口文件，开始调试时会从这个入口启动程序，我的程序的入口为server.js，修改如下： 修改完成后，点击绿色按钮，开始调试程序。 接下来用postman请求程序的接口，返现程序已经启动，并且返回了预期的数据。 接下来就是给程序设置断点，打开下想要设置断点的文件，我以刚才postman请求的用户详情接口为例，点击行号左边变为红点即设置好了断点。 再次请求用户详情接口，调试面板出现如下变化。其中划红线处按钮依次为继续、单步调试、单步跳出、重启、停止调试，在调试面板左侧可以监听变量和调用堆栈的情况等。 同时，将鼠标放在当前执行断点之前的参数或者变量上可以查看参数或者变量的详情。 好了，从此以后，就可以用VScode愉快地调试代码了。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
</search>
