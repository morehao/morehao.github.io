<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-git操作（五）]]></title>
    <url>%2F2018%2F09%2F29%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-git%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前几天，刚刚看到一个女生朋友的动态，说代码没了，还好男朋友帮忙找回来了，可能她还没了解过比男朋友还靠谱的git吧。 git是常用的代码管理工具，使用git之后，我们可以看到详细的代码修改记录，代码review时也能能够很好的甩锅了【手动捂脸】，并且也可以实现代码的备份。接下来，了解下git的基本使用吧。 注： 以下相关命令都是在项目的根目录下执行的。 本地仓库创建版本库先进入到项目的根目录，然后执行以下命令，创建项目的版本库。git init 设置忽略的文件项目中有些文件是不需要提交到远程仓库的，比如日志文件、临时文件、包含敏感信息的文件等。对于Node程序来说，node_modules/*是所有依赖包所在目录，里面包含文件过多，并且程序部署时会再次安装，所以无需提交。对于package-lock.json，因为我将该文件上传到github之后，或有潜在安全漏洞的提示，所以暂时也忽略了该文件。对于锁版本，有一个知乎的回答和另一个知乎的回答，可做参考。 项目中.gitignore文件的配置暂时如下：# Logslogsnode_modules/app/public/apidoc/package-lock.json 将文件加入版本库因为已经设置了项目要忽略的文件，所以我通常都是将项目中所有的文件加入到版本库，当然，也可以按需添加。将所有文件加入到版本库的命令如下：git add . 将文件提交到版本库上一步将需要的文件已经加入到版本库了，现在需要将上一步的文件提交到版本库，执行以下命令：git commit -m '你的提交说明信息' 当然，commit规范还是要遵循的，不清楚的，可以看我的这篇文章。 远程仓库添加远程仓库以上步骤，只是在本地代码仓库的操作流程，我们在工作过程中肯定是会使用到远程仓库的，远程仓库既可以作为本地仓库的备份，又可以进行团队协作的开发工作，所以，添加远程仓库是好的选择，执行以下命令即可：git remote add origin 你的远程仓库地址 以github为例，远程仓库地址如图所示：注：千万是你的远程仓库地址；千万是你的远程仓库地址；千万是你的远程仓库地址； 推送到远程仓库将本地仓库提交的内容推送到远程仓库，这样，就可能保证本地和远程的一致了，(当前分支为master分支)执行以下命令：git push origin master 分支管理开发和工作中，我们需要一个分支保持稳定的功能一般这个分支为master，当然，也可能存在不同版本的稳定分支，视情况而定。项目新的特性和bug修复，不会在稳定分支上进行修改和提交，所以我们需要建立新的开发分支，根据类型，我一般根据修改的类型建立不同类型的分支，比如新增需求的分支为feature/xxxx，bug修复的分支为bug/xxx，但是项目只有我自己开发，所以就没有那么严格的区分了，就只是有一个开发分支morehao_dev。 建立分支创建新的开发分支并切换到新的分支（当前代码分支为稳定版本的master分支），命令如下：git branch morehao_devgit checkout morehao_dev 或者：git checkout -b morehao_dev 推送分支将新建的开发分支推送到远程仓库，命令如下：git push origin morehao_dev:morehao_dev 在开发分支上开发完相应的需求或者修改完bug之后，需要提交并推送这些代码，和在主分支上的操作一致,流程如下：git add .git commit -m '提交说明信息'git push origin morehao_dev 分支合并开发分支的代码提交之后，如果相应修改经测试无误，就需要将这些修改同步到稳定分支，本项目的稳定分支为master分支,这时就涉及到分支合并了，分支合并的命令为git merge，我们当前的代码分支为morehao_dev，操作流程如下：git checkout mastergit pull origin mastergit merge morehao_devgit push origin master pre-commit配置现在，项目涉及到代码提交了，前面提到过的代码规范就会在现在大发神威了。 首先，安装相应库包，命令如下：npm install --save-dev pre-commitnpm install -g standard 然后，在package.json中相应位置添加如下配置："scripts": &#123; "standard": "standard"&#125;,"pre-commit": [ "standard"], 配置完成之后，进行git commit操作时，如果代码不符合规范，是不允许进行git commit操作的。 更新日志配置每一次的commit就是一次代码的更新，很好的记录这些更新，能够知道每次提交做了什么样的修改或者新增了哪些特性，熟知各个版本的变化。 首先安装相应的包，命令如下：npm install -g conventional-changelog 然后，在package.json中相应位置添加如下配置："scripts": &#123; "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0" &#125; 最后，生成更新日志，执行以下命令：npm run changelog 执行完生成更新日志的命令之后，在项目的根目录下回生成一个名为CHANGELOG.md文件，记录了更新的日志。 git常用命令上面是比较基础的git操作和一些相关配置，以下是我学习和工作中常用的git命令，不是所有的命令，但是完场日常工作，应该是足够了。 创建秘钥进入.ssh目录，如果没有改目录，创建该目录cd .ssh或 mkdir .ssh 配置公钥ssh-keygen -t rsa -C ''your email'' 复制公钥cat id_rsa.pub 将公钥粘贴到代码托管工具的相应位置 初始化本地仓库创建一个express项目express projectName 初始化本地仓库cd projectNamegit init 删除本地仓库rm -rf .git 配置远程仓库添加远程仓库git remote add origin url 删除远程仓库git remote remove origin 抓取远端仓库最新项目git pull origin master 修改后push到远端仓库git add .&lt;!--推荐按照commit日志基本规范编写commit信息--&gt;git commit git push origin master 本地分支与远程分支列出所有本地分支git branch 列出所有远程分支git branch -r 列出所有本地分支和远程分支git branch -a 建立本地分支git branch dev 建立并切换分支git checkout -b dev 推送本地分支到远程分支git push origin dev:dev 删除本地分支git branch -d dev 删除远程分支git push origin --delete dev 查看本地分支与远程分支的映射关系git branch -vv 建立本地分支与远程分支的映射关系git branch --set-upstream-to origin/dev 撤销本地分支与远程分支的映射关系git branch --unset-upstream 下载远程分支git clone url 指定下载远程分支git clone -b branchName url 暂存修改查看修改状态git status 保存当前修改进度git stash 查看保存的修改进度的列表git stash list 恢复保存的修改进度并删除保存的修改进度(默认最新)git stash pop 恢复保存的修改进度但不删除保存的修改进度（默认最新）git stash apply 恢复指定的保存并删除该保存git stash pop stash@&#123;2&#125; 暂存删除git stash drop 版本回退查看最近到最远的提交日志git log 查看最近到最远的提交日志的简要信息git log --pretty=oneline&lt;!--在git log显示的日志信息中，HEAD表示当前版本，也就是最新的版本，上个版本是HEAD^，上上个版本是HEAD^^，依次类推可以知道往上的100个版本为HEAD~100。--&gt; 版本回退git reset --hard HEAD^ 或 &lt;!--ID，不必写全，git会自动寻找相应的版本号--&gt;git reset --hard aqweq #最后参数为commitId git操作日志git reflog 打标签创建tag（标签）git tag &lt;tagName&gt; 指定标签名(-a)和标签说明(-m)git tag -a v1.4 -m 'my version 1.4' 查看所有标签git tag 将tag推送到远程仓库git push origin &lt;tagName&gt; 将所有新增的本地标签推送到远程仓库git push origin --tags 删除本地标签git tag -d &lt;tagName&gt; 删除远程仓库的标签git push origin :refs/tags/&lt;tagName&gt; 小结本文以本项目为例，完成了基本的git操作流程，并且罗列出了我常用的git命令，我对git的了解也不够深入，也正在了解git工作流程，这个词应该会经常出现在招聘信息中，如果有兴趣，可以了解下，帮助绝对不止一点点。 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-基础项目搭建（四）]]></title>
    <url>%2F2018%2F09%2F25%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基础项目搭建在上一篇文章对Express脚手架进行了简单分析和改造之后，接下来开始搭建自己的项目。 目录结构目录结构概览项目搭建的第一步，是约定项目的目录结构，项目的目录结构如下：express-blog│ CHANGELOG.md│ package.json│ README.md│ server.js │ ├─app│ ├─apidoc│ │ │ ├─controllers│ │ │ ├─middlewares│ │ │ ├─models│ │ │ ├─myutil│ ││ ├─public│ │ │ ├─routes│ │ │ └─services│ ├─build│ ├─config│ ├─logs│ ├─resource│└─test 目录结构说明目录结构说明如下： CHANGELOG.md项目更新日志的记录文件。 server.js程序的初始化和启动文件。 app/apidoc/**用于编写接口文档说明，然后使用apidoc生成接口文档。 app/controller/**用于接收和处理用户输入的参数，然后将处理结果返回。 aoo/middleware/**用于编写中间件函数。 app/model/**用于编写定义数据库相关的文件。 app/myutil/**用于存放编写的工具函数。 app/public/**用于存放项目的静态资源。 app/routes/routes.js用于添加和配置路由规则。 app/service/**用于编写业务逻辑代码，可供controller层调用。 build/**用于项目初次部署时初始化基础数据，比如初始化管理员。 config/**用于项目的相关配置文件，比如数据库配置 logs/**用于存放程序的请求日志、错误日志等日志文件。 resource/**用于存放文档资料。 test/**用于单元测试。 看到这里，不知道是否看出来些什么没有，我是尽力在向Egg.js框架的目录结构靠拢，我曾使用egg框架完成过两个web项目，使用下来的最大感受就是省心，根据egg框架核心开发人员的说法，阿里内部有很多个基于egg框架的项目在运行，起码可以得出一点，这个框架是经过多个项目实践之后的一个成果，那我们对egg框架的一点借鉴也会是好的借鉴【手动捂脸】。 基础项目搭建现在，开始按照上面的目录结构，开始搭建项目。 生成启动文件按照上一篇文章的设想，首先创建目录express-blog,将其作为项目的根目录，然后将项目的初始化文件和启动文件合二为一，在项目的根目录下创建app.js文件，代码如下：'use strict'const express = require('express')const path = require('path')const app = express()const bodyParser = require('body-parser')// 配置静态文件app.use(express.static(path.join(__dirname, 'app/public')))// 配置apidocapp.use('/apidoc', express.static(path.join(__dirname, 'app/public/apidoc/')))// 请求体解析中间件app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use(bodyParser.json())app.listen(3000)console.log('express-blog server started on: ' + 3000) 创建完成app.js文件之后，我们还需要安装文件中依赖的npm包，执行以下命令：npm init&lt;!--无所谓项目基础信息的话，执行完上面的命令之后可以一直回车，当然，还是建议认真填写--&gt;npm install --save-dev express 这时候，项目的启动文件已经创建成功，依赖包也安装完毕，可以启动项目了，就是这么简单，执行以下命令：node server.js 看到控制台输出express-blog server started on: 4000，表明我们的项目成功运行，项目初始化的第一步完成。 完成第一个接口项目已经可以成功运行，接下来要按照以上的目录结构，完成项目的第一个接口，首先，在项目的根目录下创建app目录，一般的代码文件都会放置于该目录下。然后根据以上的目录结构，创建app目录下的其他目录，待app下的目录创建完毕之后，开始编写代码。 在项目中，会将封装好的同类函数存放于目录的index.js文件中，然后导出，以供其他模块调用，在其他模块调用该目录时会默认加载该目录下的index.js具体原理见Node.js官方文档-module (模块)。 同时，在项目中，会使用ES6及ES6+的语法糖，比如Promise、class和async/await等，如果不理解，可以去看阮一峰老师的ECMAScript 6 入门，快速入口： promise对象 async函数 Class基本语法和Class继承 controller层创建app/controllers/users.js文件，代码如下：'use strict'const Services = require('../services')class UsersController &#123; async create (req, res) &#123; const paramas = req.body const result = await Services.users.addUser(paramas) res.send(result) &#125;&#125;module.exports = new UsersController() 创建app/controllers/index.js文件，代码如下：'use strict'const controllers = &#123;&#125;controllers.users = require('./users')module.exports = controllers service层创建app/services/users.js文件，代码如下：'use strict'class UserService &#123; async addUser (data) &#123; return 'create success' &#125;&#125;module.exports = new UserService() 创建app/services/index.js文件，代码如下：'use strict'const Services = &#123;&#125;Services.users = require('./users')module.exports = Services middlewares层创建app/middlewares/not-find.js文件，代码如下：'use strict'// 404错误处理中间件module.exports = (req, res, next) =&gt; &#123; res.send('404,您访问的路由不存在！')&#125; 创建app/middlewares/index.js文件，代码如下：'use strict'const middleware = &#123;&#125;middleware.notFind = require('./not-find')module.exports = middleware routes层创建app/routes/routes.js文件，同时注册上面的404错误处理中间件，代码如下：'use strict'const Controllers = require('../controllers')const middleware = require('../middlewares')module.exports = function (app) &#123; app.post('/users', Controllers.users.create) app.use(middleware.notFind)&#125; 修改app.js文件，引用路由文件，并传递app对象给routes层，添加的代码如下：// 引入路由const routes = require('./app/routes/routes')// 注册路由routes(app) 注：该代码要添加在生成app实例的代码之后，即const app = express()之后。 测试接口至此，第一个接口完成，当然，这只是一个接口，没有任何逻辑，但是也够了，逻辑可以后面再添加。接下来，对接口做简单测试。 首先，node server.js，启动程序。 然后，打开postman，发送POST请求到localhost:4000/users，发现返回create success，看来接口是生效的。 然后再发送POST请求到localhost:4000/users1212，发现返回404,您访问的路由不存在！，看来404错误处理中间件也是生效的。 小结本文主要依据上一篇文章的分析，初始化了自己的项目，完成了一个没有任何逻辑的接口（逻辑目前不重要），同时很好的完成了各层分离的目的。接下来会在此基础上，使用版本控制工具git完成一个项目相对完整的git操作流程。 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客 我的个人博客： 毛浩先生的个人博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-浅析Express脚手架（三）]]></title>
    <url>%2F2018%2F09%2F21%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E6%B5%85%E6%9E%90Express%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[既然我们的个人博客项目使用的是Express框架，那我们在项目初始化之前，先从【初始化一个Express项目】说起，分析下默认的Express脚手架。 本文篇幅稍稍有点长，超出了计划，请耐心阅读【手动捂脸】。 初始化一个Express项目在Express框架的官方文档中，是通过生成器工具express-generator快速生成了一个Express应用，相关步骤如下： 安装Express生成器npm install -g express-generator 初始化一个Express应用express express-app 如此便生成了一个名为express-app的Express应用。 目录结构概览首先来看一下这个Express应用的目录结构，目录结构如下：express-app│ app.js│ package.json│ ├─bin│ www│ ├─public│ ├─images│ ├─javascripts│ └─stylesheets│ style.css│ ├─routes│ index.js│ users.js│ └─views error.jade index.jade layout.jade 目录结构简介 app.js应用的初始化文件，包括引入应用程序的基础依赖项、设置视图即view的引擎目录以及模板、设置静态资源路径、配置通用的中间件、引入路由和一些错误处理中间件等。 package.json应用的配置文件，文件内包含程序的基础信息、启动脚本和依赖包等。 bin/www应用的启动文件，文件内包含引用要启动的应用、设置应用监听的端口和启动http服务等。 public/**应用的静态资源文件目录，该目录下的文件资源不需要经过文件映射就可以直接访问。 routes/**应用的路由文件，这些路由文件中设置的接口最终会以指定的HTTP请求方式暴露给用户，并在用户请求之后将结果返回。 views应用的视图文件，在app.js中设置好视图引擎和模板之后，该目录即为应用视图的根目录，然后路由文件就会根据app.js中的设置加载并渲染该目录下的视图文件。 应用启动首先，先要安装应用的依赖包。npm install 然后，启动程序。node bin/www 查看bin/wwww文件，拷打应用默认监听的端口是3000，然后访问localhost:3000,看到如下界面： 看到上面的页面，说明我们的应用启动成功，并且成功地访问到了视图引擎目录view中的页面。 文件详解app.js文件详解以下是初始化的Express应用中的已经做了一些注释说明后的app.js文件中的代码：// 引入依赖包var createError = require('http-errors');var express = require('express');var path = require('path');var cookieParser = require('cookie-parser');var logger = require('morgan');// 引入路由文件var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');// 创建应用实例var app = express();// 设置视图目录和模板引擎app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'jade');// 以下皆为注册中间件// 内置中间件app.use(logger('dev'));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));// 路由中间件app.use('/', indexRouter);app.use('/users', usersRouter);// 404错误处理中间件app.use(function(req, res, next) &#123; next(createError(404));&#125;);// 错误处理中间件app.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);// 导出app实例对象module.exports = app; 根据代码中的注释，我们可以看到，app.js的作用主要是初始化Express应用的一些设置，包括引入依赖包、引入路由文件、注册各类中间件的一些操作。 www文件详解以下是添加了注释后的应用启动文件bin/www中的代码：#!/usr/bin/env node// 引入依赖var app = require('../app');var debug = require('debug')('express:server');var http = require('http');// 设置应用监听的端口var port = normalizePort(process.env.PORT || '3000');app.set('port', port);// 创建http服务器var server = http.createServer(app);// 监听端口server.listen(port);server.on('error', onError);server.on('listening', onListening);// 格式化应用监听的端口function normalizePort(val) &#123; var port = parseInt(val, 10); if (isNaN(port)) &#123; // named pipe return val; &#125; if (port &gt;= 0) &#123; // port number return port; &#125; return false;&#125;// http的错误监听函数function onError(error) &#123; if (error.syscall !== 'listen') &#123; throw error; &#125; var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port; // handle specific listen errors with friendly messages switch (error.code) &#123; case 'EACCES': console.error(bind + ' requires elevated privileges'); process.exit(1); break; case 'EADDRINUSE': console.error(bind + ' is already in use'); process.exit(1); break; default: throw error; &#125;&#125;// http端口监听函数function onListening() &#123; var addr = server.address(); var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port; debug('Listening on ' + bind);&#125; bin/wwww文件的内容就很简单了，就是创建HTTP服务，监听端口和错误。 router/**详解router/**包含了路由文件，每个路由文件中包含了不同HTTP请求对用的路由以及逻辑处理函数，此处以router/index.js文件为例，以下是index.js文件的代码：// 引入依赖包var express = require('express');// 创建路由对象var router = express.Router();// 获取首页router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);module.exports = router; 路由文件主要相应相应的HTTP请求，然后执行函数进行相应的逻辑处理，以上代码，是对GET请求的响应，然后渲染view目录下的index.jade页面（在app.js中设置了视图目录和模板引擎），同时传递数据{title: &#39;Express&#39;}给index.jade页面。 view/**详解view/**主要存放应用的页面，以view/index.jade为例，代码如下：extends layoutblock content h1= title p Welcome to #&#123;title&#125; 页面文件主要是接收路由文件传递的数据，然后生成渲染后的页面给客户端，在上一步，传递了数据{title: &#39;Express&#39;}给index.jade页面，所以真实的页面应该是如下的代码：extends layoutblock content h1= 'Express' p Welcome to Express 然后客户端就看到了如下的页面： 改进缺点分析在实际开发中，我们项目的路由文件的数目会因项目复杂度而不同，当项目足够复杂时，我们需要引入的路由文件和需要注册的路由就会更多，同时除了应用本身的404和错误处理中间件之外，还可能根据实际需求新增我们自定义的中间件，如果这些初始化的代码都放置于app.js中，无疑，app.js文件会越来越大越来越臃肿，这并不是一个很好的选择。同时路由和路由对应的处理函数在一个文件中，这样的处理不够优雅，不便于维护，所以进行路由分离显得很有必要性。当然，这个应用只是生成器工具初始化的一个简单脚手架，并不是最终的样子。 MVC框架简介MVC框架是一个经典的架构模式，其中MVC分别指的是： M: Model(模型，包含数据和数据处理方法) V: View(视图，提供视图，即页面) Controller: (控制层，负责逻辑处理) 对应的，在Node中的MVC框架，处理流程应该是以下步骤： 服务端收到客户端的请求 路由层开始处理服务端接收到的请求，匹配相应的路由 匹配到相应的路由之后调用对应的controller（即对应的逻辑处理函数） controller接收到请求之后，向model层取用数据 model层接收到controller层取用数据的请求之后，将数据返回给controller层 controller层收到数据之后进行相应的逻辑处理之后，将数据返回给view层 view层收到controller层返回的数据之后，根据相应的视图模板和数据组装之后，返回一个渲染过的页面 服务端将上一步的结果返回给客户端 注：在以上的步骤中，可能会存在执行中间件的情况。 在对Express框架初始化的应用缺点和MVC有了简单了解之后，接下来就是根据以上两步的分析改进这个简单的脚手架应用了。 启动文件和初始化文件合二为一在Express的官方文档中关于app.listen()方法的介绍中，提到： Binds and listens for connections on the specified host and port. This method is identical to Node’s http.Server.listen(). 所以我们完全可以使用app.listen()方法替代bin/www中的代码逻辑，一行代码替代一个应用的启动文件，何乐而不为呢。 既然要合二为一，我们将程序的启动文件和初始化文件都合并到app.js中，这样的话，就不要要导出app对象给其他文件引入使用了，所以，首先删除app.js文件中的module.exports = app;,然后，添加一行代码即可:app.listen(3000) 修改app.js之后，访问localhost:3000,依然可以正常访问到上面的页面，说明修改无误。 抽离路由层参照MVC框架，路由层的工作是根据匹配客户端的请求路径匹配相应的路由然后调用相应的controller，以下代码为示例模板：// 访问首页app.get('/', IndexController.index) 在该小节，我们仅仅抽离出路由层，一步一步的来。 首先，在项目根目录下创建route.js文件,该文件中的代码如下：module.exports = function (app) &#123; app.get(&apos;/&apos;, function(req, res, next) &#123; console.log(&apos;new index&apos;) res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;); &#125;)&#125; 然后在app.js中添加如下代码：var routes = require(&apos;./routes&apos;)routes(app) 注：routes(app)需要在创建应用实例之后，即var app = express()之后。 同时，删除app.js中的// app.use(&#39;/&#39;, indexRouter)。 最后，访问localhost:3000,依然可以正常访问到上面的页面，并且在控制台看到输出的new index,说明修改无误。 抽离controller层首先，在根目录下创建controller/index.js，在index.js中编写如下代码：module.exports = &#123; index (req, res, next) &#123; console.log('controller') res.render('index', &#123; title: 'Express' &#125;); &#125;&#125; 然后，将routes.js修改为如下代码：var IndexController = require('./controller/index')module.exports = function (app) &#123; app.get('/', IndexController.index)&#125; 最后，访问localhost:3000,依然可以正常访问到上面的页面，并且在控制台看到输出的controller,说明修改无误。 抽离middleware层首先，在根目录下创建middlewares/not-find.js，在文件中编写以下代码：var createError = require('http-errors');module.exports = function(req, res, next) &#123; next(createError(404));&#125; 然后在app.js中，引入相关中间件：var notFind = require('./middlewares/not-find') 然后修改404错误处理中间件为：// 404错误处理中间件app.use(notFind); 最后，访问localhost:3000/asasasasasa,这是一个不存在的路径，应该会出现404页面，发现可以正常访问到404页面，说明修改无误。 其他自定义中间件的处理，同理。 小结至此，我们对生成器工具express-generator生成的Express应用的改造完毕，并且接下来初始化自己的应用可以不再使用express-generator，可以根据自己的需求，参照以上修改，进行项目初始化搭建。 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-开发准备（二）]]></title>
    <url>%2F2018%2F09%2F19%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[技术栈 平台： Node.js（v8.9.3） 框架：Express（v4.16.0） 数据库：MongoDB（v3.4.14） 开发环境 Node相关：下载链接 MongoDB相关：下载链接 Node与MongoDB的下载与安装，请自行百度或谷歌，遍地都是，不再赘述。 相关规范相关规范主要包括代码规范、Git commit规范和API接口文档规范。 代码规范代码规范采用JavaScript Standard Style,以下简称standard规范。至于为什么使用这个代码规范，没有什么特殊原因，这是我使用过的第一个代码规范，是我规范自己代码的开始，习惯而已，并且github上的start数也不算少。standard规范相比较ESLint而言，最舒服的一点就是不用配置，对我影响最大的一点是代码中再也没有出现分号，并且强迫症再也受不了代码中有分号【捂脸】，以至于后来使用ESLint时，也要配置为可以不写分号【再次捂脸】。 通过代码规范，可以在编程过程中避免一些低级错误，比如使用未定义的变量等，同时可以规范自己的代码书写风格，有了规范代码的习惯，写出来的代码赏心悦目，看着也舒服很多，一定程度上增加了代码的可读性，工作效率的提升也是必然的事情。 我听说过，有的团队的代码规范及其严格，比如一行代码最大字符长度不能超过120甚至80，每个函数的代码行数不能超过50行等，存在必有意义吧，起初没必要对自己这么严格，但是代码规范还是要重视起来的。 工具配合我使用的编辑器是VS Code,可以安装StandardJS插件，非常方便。 同时可以配合一个npm的库包pre-commit进行代码规范，因为不规范的代码是不会影响程序的正常运行的，但我们使用代码规范的目的就是希望提交到代码仓库的代码都是规范的，pre-commit的作用就是在进行commit操作时检测所有代码是否符合standard规范，如果不符合则不允许提交代码。 相关参考在standard规范的文档中，有关于规范的细则和使用过程中可能出现的问题。 standard规范的中文文档 standard规范的github链接 pre-commit链接 Git commit规范我们进行commit操作时，填写的相关说明一定是要有意义的，我记得在学习编程的最开始，我们的对git的命令以及操作规范不清楚，所以commit的信息乱七八糟，经常是“解决冲突”、“修改bug”这样的说明，在被批评之后，也仅仅是commit信息不再胡写。 项目的commit message规范使用的是主流的Angular规范，在实际的团队开发中，通过对commit日志的规范，有助于代码的review、日志的自动化生成以及项目发版，同时能够很好地熟悉git工作流。在该项目中不涉及发版，只是简单的开发，所以只是遵循了部分规范，在实际工作中，如果团队刚好涉及到git工作流的规范，那肯定是要遵循的。 Git commit日志基本规范基础语法模板&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 规范的基本说明：type代表本次提交的类型，是新增feature还是修复bug或是修改文档等，主要类型及其说明如下： feat：新增feature fix: 修复bug docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 优化相关，比如提升性能、体验 test: 测试用例，包括单元测试、集成测试等 chore: 改变构建流程、或者增加依赖库、工具等 revert: 回滚到上一个版本 scope表明本次修改的范围或者模块，例如users。 subject是对变更内容的简要描述。 BLANK LINE不用说，就是字面意思的空白行。 body是对本次变更更加详细的说明，可以是发起本次变更的原因以及本次变更的解决思路和方法等。 footer处填写相关连接。 格式要求：# 标题行：50个字符以内，描述主要变更内容# （我是空行）# 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:# （我是空行）# * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险? ## 尾部：如果需要的话可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。 相关参考Git commit message和工作流规范 API接口文档规范我写过的第一个接口文档，是word形式的，写了大概三个接口就受不了了，word写接口，太不舒服了，后来用showdoc工具写接口文档，好用了很多，但是没有很好地体现文档的维护记录，再后来，参加工作之后接触了解了apidoc，相对而言，它也算主流之一，使用简单并且支持多语言，所以就开始使用apidoc作为生成接口文档的工具，接口文档在代码中以注解的形式书写，然后通过apidoc的相关命令生成接口文档，配合git刚好可以很好地体现接口文档的维护记录。当然，还有其他选择，个人喜好而已。 apidoc编写接口示例代码实例：/** * @api &#123;POST&#125; /user create a user * @apiDescription 用户新增的接口 * @apiName 用户注册 * @apiGroup User * @apiUse userParams * @apiSuccessExample Success-Response: * &#123; * errorCode: 0, * status: 200, * data: &#123; * _id: '123', * name: 'morehao', * createdAt: '20180913', * updatedAt: '20180913', * lastLogin: '暂未登录' * &#125; * &#125; * @apiErrorExample &#123;json&#125; Error-Response: * &#123; * status: 200, * errorCode: 20100, * errorMsg: '该用户已经存在' * &#125;*/ 截图实例： 相关参考这里只确定API接口文档的生成方式，详细的使用后面也不会过多涉及，下面附上相关链接。 apidoc官方网站 apidoc文档的官方示例 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+Express搭建个人博客（纯后端）-前言（一）]]></title>
    <url>%2F2018%2F09%2F18%2FNode-Express%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%BA%AF%E5%90%8E%E7%AB%AF%EF%BC%89-%E5%89%8D%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目的目的是什么首先说明，项目的目的并不是写教程，我目前的水平还处于菜鸟级别，若有指正，菜鸟必改之。 我刚刚开始学习编程的时候，我的老师告诉我先做一个个人博客来练手，当时没怎么听，也只是走了个过场，刚好可以完成下当年没有做的博客。同时，通过完成个人博客项目，我想要把之前学习到的、接触到的和工作中使用到的经验，比如搭建基础的项目框架，比如代码规范和Git commit规范，比如路由分离，比如错误处理等等，尽可能地体现在这个功能简单的个人博客中。 总之，本项目的目的并不是要做多么酷炫的功能，也不是想要做什么教程，仅仅是个人经验的总结，希望即使是一个个人博客系统也可以像一个工程。当然，如果能够帮助到一些人，那也是极好的【手动捂脸】。 项目的预期我是一个【纯粹】的Node后端开发，说是纯粹，其实是菜，前端的东西，我看到就头大，目前也不太想花费精力去学习前端的东西，所以本项目完成之后，有的只是一个个人博客所拥有的基础功能的——一堆接口【手动捂脸】，我也尝试着使用iview提供的一套后台管理系统进行改写，写了几天之后，发现意义不大，我的想法并不是做一个完善的包含前后端的个人博客，所以也就放弃了。 所以，综上，你不会看到酷炫的功能，更看不到酷炫的页面，这里只会有一堆接口，当然，我会提供较为完善的接口文档，毕竟，接口文档也是项目开发过程中极为重要的一部分。 项目的结果虽然只是一个简单的纯后端的个人博客，但是在完成这个项目的过程中还是学习到不少的知识，也对有些曾经不太熟悉的东西有了新的认识，并且项目已经完成，可能还有一些地方需要完善，比如接口文档知识写了示例，比如测试代码也只是写了一个接口，这些不完善的地方，我应该还是会去完善的，不过，我是不定期完善【手动捂脸】。 下面附上项目的github地址： 项目地址 我的简书： 毛浩先生的简书博客]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node回调函数改写]]></title>
    <url>%2F2018%2F06%2F26%2FNode%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%94%B9%E5%86%99%2F</url>
    <content type="text"><![CDATA[以读取文件为例，首先，创建文件a.txt，文件内写入内容Hello world!。 回调函数写法const fs = require('fs')fs.readFile('./a.txt', 'utf-8', (err, data) =&gt; &#123; if (err) throw err console.log(data)&#125;) Promise写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;getTxt('./a.txt') .then(rst =&gt; console.log(rst)) bluebird写法const Promise = require('bluebird')const fs = Promise.promisifyAll(require('fs'))fs.readFileAsync('./a.txt', 'utf-8') .then(data =&gt; console.log(data)) Generator写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;function * fun () &#123; yield getTxt('./a.txt')&#125;const run = fun()run.next().value.then(data =&gt; console.log(data)) async/await写法const fs = require('fs')function getTxt (path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;async function run (params) &#123; const file = await getTxt(params) console.log(file) return file&#125;run('./a.txt')]]></content>
      <categories>
        <category>Node.js学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用VScode断点调试Node.js]]></title>
    <url>%2F2018%2F05%2F09%2F%E4%BD%BF%E7%94%A8VScode%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Node-js%2F</url>
    <content type="text"><![CDATA[这是个告别console的开始【手动捂脸】。 首先，打开虫子，进入调试页面。 点击绿色的按钮，开始调试。 选择环境Node.js。 选择完成之后，生成一个.vscode文件夹，文件夹下有个launch.json文件。 将【program】字段的值修改为自己程序的入口文件，开始调试时会从这个入口启动程序，我的程序的入口为server.js，修改如下： 修改完成后，点击绿色按钮，开始调试程序。 接下来用postman请求程序的接口，返现程序已经启动，并且返回了预期的数据。 接下来就是给程序设置断点，打开下想要设置断点的文件，我以刚才postman请求的用户详情接口为例，点击行号左边变为红点即设置好了断点。 再次请求用户详情接口，调试面板出现如下变化。其中划红线处按钮依次为继续、单步调试、单步跳出、重启、停止调试，在调试面板左侧可以监听变量和调用堆栈的情况等。 同时，将鼠标放在当前执行断点之前的参数或者变量上可以查看参数或者变量的详情。 好了，从此以后，就可以用VScode愉快地调试代码了。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
</search>
